//! # DBus interface proxies for: `org.freedesktop.systemd1.Service`, `org.freedesktop.systemd1.Unit`
//!
//! This code was generated by `zbus-xmlgen` `2.0.1` from DBus introspection data.
//! Source: `Interface '/org/freedesktop/systemd1/unit/postgresql_2eservice' from service 'org.freedesktop.systemd1' on system bus`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the
//! [Writing a client proxy](https://dbus.pages.freedesktop.org/zbus/client.html)
//! section of the zbus documentation.
//!
//! This DBus object implements
//! [standard DBus interfaces](https://dbus.freedesktop.org/doc/dbus-specification.html),
//! (`org.freedesktop.DBus.*`) for which the following zbus proxies can be used:
//!
//! * [`zbus::fdo::PeerProxy`]
//! * [`zbus::fdo::IntrospectableProxy`]
//! * [`zbus::fdo::PropertiesProxy`]
//!
//! â€¦consequently `zbus-xmlgen` did not generate code for the above interfaces.

use zbus::dbus_proxy;

#[dbus_proxy(
    interface = "org.freedesktop.systemd1.Unit",
    default_service = "org.freedesktop.systemd1"
)]
trait Unit {
    /// Clean method
    fn clean(&self, mask: &[&str]) -> zbus::Result<()>;

    /// EnqueueJob method
    fn enqueue_job(
        &self,
        job_type: &str,
        job_mode: &str,
    ) -> zbus::Result<(
        u32,
        zbus::zvariant::OwnedObjectPath,
        String,
        zbus::zvariant::OwnedObjectPath,
        String,
        Vec<(
            u32,
            zbus::zvariant::OwnedObjectPath,
            String,
            zbus::zvariant::OwnedObjectPath,
            String,
        )>,
    )>;

    /// Freeze method
    fn freeze(&self) -> zbus::Result<()>;

    /// Kill method
    fn kill(&self, whom: &str, signal: i32) -> zbus::Result<()>;

    /// Ref method
    fn ref_(&self) -> zbus::Result<()>;

    /// Reload method
    fn reload(&self, mode: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// ReloadOrRestart method
    fn reload_or_restart(&self, mode: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// ReloadOrTryRestart method
    fn reload_or_try_restart(&self, mode: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// ResetFailed method
    fn reset_failed(&self) -> zbus::Result<()>;

    /// Restart method
    fn restart(&self, mode: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// SetProperties method
    fn set_properties(
        &self,
        runtime: bool,
        properties: &[(&str, zbus::zvariant::Value<'_>)],
    ) -> zbus::Result<()>;

    /// Start method
    fn start(&self, mode: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// Stop method
    fn stop(&self, mode: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// Thaw method
    fn thaw(&self) -> zbus::Result<()>;

    /// TryRestart method
    fn try_restart(&self, mode: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// Unref method
    fn unref(&self) -> zbus::Result<()>;

    /// ActiveEnterTimestamp property
    #[dbus_proxy(property)]
    fn active_enter_timestamp(&self) -> zbus::Result<u64>;

    /// ActiveEnterTimestampMonotonic property
    #[dbus_proxy(property)]
    fn active_enter_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// ActiveExitTimestamp property
    #[dbus_proxy(property)]
    fn active_exit_timestamp(&self) -> zbus::Result<u64>;

    /// ActiveExitTimestampMonotonic property
    #[dbus_proxy(property)]
    fn active_exit_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// ActiveState property
    #[dbus_proxy(property)]
    fn active_state(&self) -> zbus::Result<String>;

    /// After property
    #[dbus_proxy(property)]
    fn after(&self) -> zbus::Result<Vec<String>>;

    /// AllowIsolate property
    #[dbus_proxy(property)]
    fn allow_isolate(&self) -> zbus::Result<bool>;

    /// AssertResult property
    #[dbus_proxy(property)]
    fn assert_result(&self) -> zbus::Result<bool>;

    /// AssertTimestamp property
    #[dbus_proxy(property)]
    fn assert_timestamp(&self) -> zbus::Result<u64>;

    /// AssertTimestampMonotonic property
    #[dbus_proxy(property)]
    fn assert_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// Asserts property
    #[dbus_proxy(property)]
    fn asserts(&self) -> zbus::Result<Vec<(String, bool, bool, String, i32)>>;

    /// Before property
    #[dbus_proxy(property)]
    fn before(&self) -> zbus::Result<Vec<String>>;

    /// BindsTo property
    #[dbus_proxy(property)]
    fn binds_to(&self) -> zbus::Result<Vec<String>>;

    /// BoundBy property
    #[dbus_proxy(property)]
    fn bound_by(&self) -> zbus::Result<Vec<String>>;

    /// CanClean property
    #[dbus_proxy(property)]
    fn can_clean(&self) -> zbus::Result<Vec<String>>;

    /// CanFreeze property
    #[dbus_proxy(property)]
    fn can_freeze(&self) -> zbus::Result<bool>;

    /// CanIsolate property
    #[dbus_proxy(property)]
    fn can_isolate(&self) -> zbus::Result<bool>;

    /// CanReload property
    #[dbus_proxy(property)]
    fn can_reload(&self) -> zbus::Result<bool>;

    /// CanStart property
    #[dbus_proxy(property)]
    fn can_start(&self) -> zbus::Result<bool>;

    /// CanStop property
    #[dbus_proxy(property)]
    fn can_stop(&self) -> zbus::Result<bool>;

    /// CollectMode property
    #[dbus_proxy(property)]
    fn collect_mode(&self) -> zbus::Result<String>;

    /// ConditionResult property
    #[dbus_proxy(property)]
    fn condition_result(&self) -> zbus::Result<bool>;

    /// ConditionTimestamp property
    #[dbus_proxy(property)]
    fn condition_timestamp(&self) -> zbus::Result<u64>;

    /// ConditionTimestampMonotonic property
    #[dbus_proxy(property)]
    fn condition_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// Conditions property
    #[dbus_proxy(property)]
    fn conditions(&self) -> zbus::Result<Vec<(String, bool, bool, String, i32)>>;

    /// ConflictedBy property
    #[dbus_proxy(property)]
    fn conflicted_by(&self) -> zbus::Result<Vec<String>>;

    /// Conflicts property
    #[dbus_proxy(property)]
    fn conflicts(&self) -> zbus::Result<Vec<String>>;

    /// ConsistsOf property
    #[dbus_proxy(property)]
    fn consists_of(&self) -> zbus::Result<Vec<String>>;

    /// DefaultDependencies property
    #[dbus_proxy(property)]
    fn default_dependencies(&self) -> zbus::Result<bool>;

    /// Description property
    #[dbus_proxy(property)]
    fn description(&self) -> zbus::Result<String>;

    /// Documentation property
    #[dbus_proxy(property)]
    fn documentation(&self) -> zbus::Result<Vec<String>>;

    /// DropInPaths property
    #[dbus_proxy(property)]
    fn drop_in_paths(&self) -> zbus::Result<Vec<String>>;

    /// FailureAction property
    #[dbus_proxy(property)]
    fn failure_action(&self) -> zbus::Result<String>;

    /// FailureActionExitStatus property
    #[dbus_proxy(property)]
    fn failure_action_exit_status(&self) -> zbus::Result<i32>;

    /// Following property
    #[dbus_proxy(property)]
    fn following(&self) -> zbus::Result<String>;

    /// FragmentPath property
    #[dbus_proxy(property)]
    fn fragment_path(&self) -> zbus::Result<String>;

    /// FreezerState property
    #[dbus_proxy(property)]
    fn freezer_state(&self) -> zbus::Result<String>;

    /// Id property
    #[dbus_proxy(property)]
    fn id(&self) -> zbus::Result<String>;

    /// IgnoreOnIsolate property
    #[dbus_proxy(property)]
    fn ignore_on_isolate(&self) -> zbus::Result<bool>;

    /// InactiveEnterTimestamp property
    #[dbus_proxy(property)]
    fn inactive_enter_timestamp(&self) -> zbus::Result<u64>;

    /// InactiveEnterTimestampMonotonic property
    #[dbus_proxy(property)]
    fn inactive_enter_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// InactiveExitTimestamp property
    #[dbus_proxy(property)]
    fn inactive_exit_timestamp(&self) -> zbus::Result<u64>;

    /// InactiveExitTimestampMonotonic property
    #[dbus_proxy(property)]
    fn inactive_exit_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// InvocationID property
    #[dbus_proxy(property)]
    fn invocation_id(&self) -> zbus::Result<Vec<u8>>;

    /// Job property
    #[dbus_proxy(property)]
    fn job(&self) -> zbus::Result<(u32, zbus::zvariant::OwnedObjectPath)>;

    /// JobRunningTimeoutUSec property
    #[dbus_proxy(property)]
    fn job_running_timeout_usec(&self) -> zbus::Result<u64>;

    /// JobTimeoutAction property
    #[dbus_proxy(property)]
    fn job_timeout_action(&self) -> zbus::Result<String>;

    /// JobTimeoutRebootArgument property
    #[dbus_proxy(property)]
    fn job_timeout_reboot_argument(&self) -> zbus::Result<String>;

    /// JobTimeoutUSec property
    #[dbus_proxy(property)]
    fn job_timeout_usec(&self) -> zbus::Result<u64>;

    /// JoinsNamespaceOf property
    #[dbus_proxy(property)]
    fn joins_namespace_of(&self) -> zbus::Result<Vec<String>>;

    /// LoadError property
    #[dbus_proxy(property)]
    fn load_error(&self) -> zbus::Result<(String, String)>;

    /// LoadState property
    #[dbus_proxy(property)]
    fn load_state(&self) -> zbus::Result<String>;

    /// Markers property
    #[dbus_proxy(property)]
    fn markers(&self) -> zbus::Result<Vec<String>>;

    /// Names property
    #[dbus_proxy(property)]
    fn names(&self) -> zbus::Result<Vec<String>>;

    /// NeedDaemonReload property
    #[dbus_proxy(property)]
    fn need_daemon_reload(&self) -> zbus::Result<bool>;

    /// OnFailure property
    #[dbus_proxy(property)]
    fn on_failure(&self) -> zbus::Result<Vec<String>>;

    /// OnFailureJobMode property
    #[dbus_proxy(property)]
    fn on_failure_job_mode(&self) -> zbus::Result<String>;

    /// OnFailureOf property
    #[dbus_proxy(property)]
    fn on_failure_of(&self) -> zbus::Result<Vec<String>>;

    /// OnSuccess property
    #[dbus_proxy(property)]
    fn on_success(&self) -> zbus::Result<Vec<String>>;

    /// OnSuccessJobMode property
    #[dbus_proxy(property)]
    fn on_success_job_mode(&self) -> zbus::Result<String>;

    /// OnSuccessOf property
    #[dbus_proxy(property)]
    fn on_success_of(&self) -> zbus::Result<Vec<String>>;

    /// PartOf property
    #[dbus_proxy(property)]
    fn part_of(&self) -> zbus::Result<Vec<String>>;

    /// Perpetual property
    #[dbus_proxy(property)]
    fn perpetual(&self) -> zbus::Result<bool>;

    /// PropagatesReloadTo property
    #[dbus_proxy(property)]
    fn propagates_reload_to(&self) -> zbus::Result<Vec<String>>;

    /// PropagatesStopTo property
    #[dbus_proxy(property)]
    fn propagates_stop_to(&self) -> zbus::Result<Vec<String>>;

    /// RebootArgument property
    #[dbus_proxy(property)]
    fn reboot_argument(&self) -> zbus::Result<String>;

    /// Refs property
    #[dbus_proxy(property)]
    fn refs(&self) -> zbus::Result<Vec<String>>;

    /// RefuseManualStart property
    #[dbus_proxy(property)]
    fn refuse_manual_start(&self) -> zbus::Result<bool>;

    /// RefuseManualStop property
    #[dbus_proxy(property)]
    fn refuse_manual_stop(&self) -> zbus::Result<bool>;

    /// ReloadPropagatedFrom property
    #[dbus_proxy(property)]
    fn reload_propagated_from(&self) -> zbus::Result<Vec<String>>;

    /// RequiredBy property
    #[dbus_proxy(property)]
    fn required_by(&self) -> zbus::Result<Vec<String>>;

    /// Requires property
    #[dbus_proxy(property)]
    fn requires(&self) -> zbus::Result<Vec<String>>;

    /// RequiresMountsFor property
    #[dbus_proxy(property)]
    fn requires_mounts_for(&self) -> zbus::Result<Vec<String>>;

    /// Requisite property
    #[dbus_proxy(property)]
    fn requisite(&self) -> zbus::Result<Vec<String>>;

    /// RequisiteOf property
    #[dbus_proxy(property)]
    fn requisite_of(&self) -> zbus::Result<Vec<String>>;

    /// SliceOf property
    #[dbus_proxy(property)]
    fn slice_of(&self) -> zbus::Result<Vec<String>>;

    /// SourcePath property
    #[dbus_proxy(property)]
    fn source_path(&self) -> zbus::Result<String>;

    /// StartLimitAction property
    #[dbus_proxy(property)]
    fn start_limit_action(&self) -> zbus::Result<String>;

    /// StartLimitBurst property
    #[dbus_proxy(property)]
    fn start_limit_burst(&self) -> zbus::Result<u32>;

    /// StartLimitIntervalUSec property
    #[dbus_proxy(property)]
    fn start_limit_interval_usec(&self) -> zbus::Result<u64>;

    /// StateChangeTimestamp property
    #[dbus_proxy(property)]
    fn state_change_timestamp(&self) -> zbus::Result<u64>;

    /// StateChangeTimestampMonotonic property
    #[dbus_proxy(property)]
    fn state_change_timestamp_monotonic(&self) -> zbus::Result<u64>;

    /// StopPropagatedFrom property
    #[dbus_proxy(property)]
    fn stop_propagated_from(&self) -> zbus::Result<Vec<String>>;

    /// StopWhenUnneeded property
    #[dbus_proxy(property)]
    fn stop_when_unneeded(&self) -> zbus::Result<bool>;

    /// SubState property
    #[dbus_proxy(property)]
    fn sub_state(&self) -> zbus::Result<String>;

    /// SuccessAction property
    #[dbus_proxy(property)]
    fn success_action(&self) -> zbus::Result<String>;

    /// SuccessActionExitStatus property
    #[dbus_proxy(property)]
    fn success_action_exit_status(&self) -> zbus::Result<i32>;

    /// Transient property
    #[dbus_proxy(property)]
    fn transient(&self) -> zbus::Result<bool>;

    /// TriggeredBy property
    #[dbus_proxy(property)]
    fn triggered_by(&self) -> zbus::Result<Vec<String>>;

    /// Triggers property
    #[dbus_proxy(property)]
    fn triggers(&self) -> zbus::Result<Vec<String>>;

    /// UnitFilePreset property
    #[dbus_proxy(property)]
    fn unit_file_preset(&self) -> zbus::Result<String>;

    /// UnitFileState property
    #[dbus_proxy(property)]
    fn unit_file_state(&self) -> zbus::Result<String>;

    /// UpheldBy property
    #[dbus_proxy(property)]
    fn upheld_by(&self) -> zbus::Result<Vec<String>>;

    /// Upholds property
    #[dbus_proxy(property)]
    fn upholds(&self) -> zbus::Result<Vec<String>>;

    /// WantedBy property
    #[dbus_proxy(property)]
    fn wanted_by(&self) -> zbus::Result<Vec<String>>;

    /// Wants property
    #[dbus_proxy(property)]
    fn wants(&self) -> zbus::Result<Vec<String>>;
}
